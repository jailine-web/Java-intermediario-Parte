Para falar que a classe é um recurso web que é implementado 
por um controlador rest utiliza-se a anotação: @RestController
em cima do nome da classe.
A anotação @RequestMapping um nome/apelido para o recurso

Testar se o recurso está funcionado:

O tipo ResponseEntity retorna respostas de requisições web
Método(endpoint) para acessar os usuários: findAll().
.ok() para retornar a resposta com sucesso no http.
.body() retorna o corpo da resposta do usuário(u) que foi instanciado

Para indicar que o método vai ser um método que responde a requisição
do tipo get http coloca-se a anotação @GetMapping

Para testar:
1- Clica no botão verde (local) na IDE
2- Clica em cima do projeto com o botão direito do mouse
3- Clica em restart
4- Se não tiver erros
5- Abre o navegador
6- insere o link: localhost:8080/nomeDoRecurso.


#### H2 ####

H2 é um banco de dados em memória (não precisa instalar nada no computador), 
muito utilizado em java para fazer testes na aplicação.
ele já vem integrado ao projeto.

profile de teste é um perfil do projeto específico para realizar testes.
Sobre o arquivo application-test.properties:
spring.datasource.url=jdbc:h2:mem:testdb é a String de conexão dom o banco 
de dados. O nome dado ao banco foi testedb.

Nome do usuário é sa e a senha está vazia.
O comando spring.h2.console.enable=true define que o concole está habilitado
O comando spring.h2.console.path=/h2-console define que o caminho para acessar 
o adm do H2 é /h2-console 

As duas últimas especificações são referntes ao JPA.

show-sql: serve para mostrar no log da aplicação o comando SQL que foi executado
 pelo JPA. o outro é para formatar o SQL de forma que ele fique mais legível.

### anototation/anotação para uma classe ser uma entidade do sistema gerenciada pelo JPA 
é preciso inserir as anotações(mapeamentos) do JPA(@Entity, Table(name="nomeDesejado"), @Id, @Generated)  

### configuração de testes ###

Para indicar que a classe é uma específica de configuração é necessário inserir a anotação
@Configuration. E para dizer que a classe é uma config especifica para o perfil de teste é 
necessário inserir a anotação @Profile("test"); nome inserido na primeira linha do arquivo 
application.properties.
A classe testCon... serve popular o banco de dados com objetos, e para 
Repository salva os dados
@Autowired serve para realizar a injeção de dependências, indicando o ponto exato onde a injeção
 automática deve ser aplicada, podendo ser utilizada em métodos, atributos e construtores 
<https://medium.com/@leonardogiuliani/autowired-e-a-inje%C3%A7%C3%A3o-de-depend%C3%AAncia-do-spring-d8864cc9af50> 

## CommandLine ##

Tudo que estiver dentro do método run será executado quando a aplicação for iniciada

## Camada de serviço ##

A camada de serviço realiza o meio de campo entre a camada de controle e a camada de repositórios

Onde fica as regras de negócio. Criar validações para não sobrecarregar o controlador com diversas 
regras de negócios fazendo com que o controlador fique responsável apenas pela intermediação entre 
a aplicação e as regras de negócio. 

@Component/@Service/@repository - Registra sua classe como um componente do Spring para que injeção
de dependência possa ser realizada pela anotação @autowired

A anotação @GetMapping(value = "/{id}") permite que o id seja passado via url, dizendo que a url tem 
um parâmetro.

Para receber o parâmetro e aceitá-lo coloca-se o @PathVariable

## Order (Pedido) M##

Relacionamento entre pedido e cliente para o JPA transformar isso em chave estrangeira no banco de 
dados. A anotação @ManyToOne define o relacionamento muitos para um, mapeando os definitivos atributos
A anotação @JoinColumn( name ="client_id") -> da o nome a chave estrangeira que será criada no BD

@OneToMany(mappedBy = "client") liga os relacionametos por meio do cliente integrado na classe 
Order --> private User client;
@Table(name ="tb_order") renomeia a tabela no BD

Formato da data ISO8601;
JsonIgnore em um dos lados evitar loop infinito causado pelo relacionamento criado dos dois lados (cliente(User) e Order)

O comando : spring.jpa.open-in-view = true permite que o jackson gerencie o json especificando que os clientes irá precisar 
dos pedidos dos usuários (vice-versa) e ele aciona o JPA para que trazer dos banco de dados esses pedidos. Ex: chama os 
cliente associados ao pedido e vice-versa.

Para garantir que o instante seja mostrado no json no formato de ISO 8606 utiliza-se a anotation do jackson: 
@JsonFormat(shape = JsonFormat.shape.string, pattern = "yyyy-dd-'T'HH:mm:ss'Z'", timezone="GMT")








